# ABR & Congestion Control

## ABR 
- 码率自适应技术，部署在客户端
- 输入网络状况和本地播放缓冲信息，输出下一个片段的请求码率，目标是最大化用户观看体验QoE
- 发送端将原始视频转码为多种不同分辨率/比特率的文件，并且把文件切片为2~10s大小的数据块
- 客户端根据自己的网络情况和缓冲区大小进行码率决策，选择合适比特率的数据块下载
- buffer-based
	- 基于客户端的播放缓冲区情况决策下一片段的码率档位
	- 设置保护窗口，当buffer小于保护窗口的时候，降低码率
- rate-based
	- 基于预测的带宽决策下一片段的码率档位
- learning-based
	- 基于强化学习，输入网络和缓冲区信息，决策下一次请求码率，奖励函数为QoE函数

## Congestion Control
- 拥塞控制，部署在服务器
- 输入接收端反馈的ACK信息，输出发送速率。目的是在不超过网络负载量的情况下尽可能提高吞吐量(bandwidth)，并降低往返延迟(RTT)。拥塞控制一般还需要保证多个流竞争的公平性和收敛性
- loss-based：基于丢包的算法把丢包视为拥塞的标志，并在拥塞时降低发送速率，常见算法为Reno和Cubic。这些算法适用于稳定基本不丢包的网络，缺点是发生随机丢包时会大幅降低吞吐量，当网络瓶颈节点的缓冲比较大时，延迟也大，因为它会不断提高发送速率直到填满缓冲。
- delay-based：基于延迟的算法当估计的RTT变大时自动降低发送速率，例如Vegas和Fast TCP。它的优点是延迟比较低，缺点是无法和基于丢包的算法竞争流量。
- congestion-based：BBR是基于拥塞的算法，不把丢包作为拥塞标志，而是通过估计带宽BW和最小往返延迟RTT计算带宽延迟积BDP (BDP = BW * RTT). 通过调整send_rate和pacing_rate控制inflight=BDP (inflight表示已经发送但是还没ACK的数据大小)，以此达到高吞吐量和低延迟
- learning-based：一般是基于强化学习的算法，将拥塞控制问题转为强化学习任务。
	- actions: 下一个时间段的发送速率
	- states: 一段时间网络状态信息构成的向量，包括延迟梯度，发送比率等
	- reward: 根据网络应用的需求设计，一般设计为高吞吐量和低延迟

## Comparison & Relation
- 拥塞控制算法控制了整个网络传输的数据吞吐量，相当于决定了管道的大小
- ABR算法根据当前网络状况向服务器请求合适的比特率的视频片段，相当于决定了管道内传输的内容
- 拥塞控制算法主动影响网络状况，而ABR算法察觉到了网络状况的变化，被动选择合适的视频片段。例如，当拥塞控制算法让发送速率降低，网络吞吐量下降，ABR算法就请求低码率的视频片段
- 两者的目标不同：拥塞控制的目的是最大化利用网络容量，并不至于超过负载，因此需要保证最大带宽和最小RTT。ABR算法的目的是请求合适码率的视频块，让播放器无卡顿并提供高质量QoE
- 两者覆盖场景不同：拥塞控制不针对特定数据格式，可以传输任意数据，它只控制源端发送到网络的速率；而ABR算法仅针对HTTP流媒体传输，要求服务器提供多种码率的视频片段。
- 联系： 两者可以联合对视频传输进行优化，例如Stanford Puffer团队提出的Fugu算法利用拥塞控制计算的带宽和cwnd等信息，利用机器学习方法构建高效的ABR算法。

## 参考链接
`https://blog.csdn.net/qq_40795227/article/details/94592916`  
`https://www.wowza.com/blog/adaptive-bitrate-streaming`  
`Learning in situ: a randomized experiment in video streaming`
