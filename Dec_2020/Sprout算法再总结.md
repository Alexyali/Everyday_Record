# Sprout算法再总结

`Stochastic Forecasts Achieve High Throughput and Low Delay over Cellular Networks`  

`NSDI 13`  

### 简述

Sprout是一个为交互式应用设计的端到端传输协议。它工作在链路带宽快速变化的蜂窝无线网络下，可以取得高吞吐量和低延迟。

Sprout的接收端观察到数据包到达时间，推断网络路径的不确定性。这个推断用于预测发送端可以安全发送的比特数，并且约束数据包在网络中延迟太久的风险。

- Sprout本质将网络队列排空建模为动态泊松过程，然后根据数据包到达时间更新概率分布的估计
- 通过估计一定时间内队列排空的比特数以及队列占用情况判断发送端在下一个时间段可以安全发送的比特数

### 动机

下行网络的MTU大小的数据包到达间隔时间的分布非常符合无记忆过程，也就是泊松过程。一个泊松过程拥有基础速率λ，就是一段间隔内到达的比特数除以间隔时间。

Sprout需要估计现在以及未来的链路速率，未来预测可以安全发送的数据包的数量。算法首先建模链接并估计其行为，然后采用该模型预测该链接最近将会从队列中传输的比特数。

### 1 推断泊松过程的速率

作者将这个链接建模为双重随机过程，泊松过程的速率λ按照布朗运动变化。将网络队列排空的过程建模为泊松过程。速率λ控制该泊松过程，它也随布朗运动变化。如果数据传输中断，则加入一个逃离速率。

唯一需要实时推断的参数是λ，也就是变化的链路速率。

![1](https://github.com/Alexyali/Everyday_Record/blob/master/Dec_2020/12-14-model.PNG)

Sprout将速率λ可能的取值空间离散化为256个平均分布的离散值。从0-1000个MTU包每秒。每一个tick(20ms)执行一次推断更新过程。

### 2 速率λ的概率分布的进化

每个tick，Sprout执行三个动作

- 更新当前时间的概率分布，应用布朗运动到每个λ
- 观察最近一次tick期间进入的比特数。该步骤将每个概率和相似性相乘，该相似性是用相应速率的泊松分布在一个tick观察到的计算得到的。假设每个tick长度为`τ`，此期间观察到k个比特，更新概率函数F

$$
F(x) = P_{old}(λ=x)\frac{(xτ)^k}{k!}exp[-xτ]
$$

- 将λ的256个概率值归一化，使其和为1

### 3 数据包交付预测

给定速率的概率分布，接收端可以预测发送端可以安全发送的比特数，而且数据包不会在队列中停留太长时间。Sprout计算一个数据包交付预测：在之后的8个tick中，**多少比特的数据将会到达接收端**。

它将概率分布向前发展到预测的8个tick中。在每个tick中，Sprout对每个速率λ求和，找到该时刻被排空的累积数据包的概率分布。作者取这个分布的5%作为每个tick的预测。

### 4 控制协议

Sprout的接收端将预测值放到数据包中发给发送端。预测还包含接收端以及收到的总比特数。这可以帮助发送端估计队列中的比特数。

### 5 使用预测结果

Sprout发送端使用最近获得的预测值用于计算窗口大小，可以安全传输的比特数。接收到预测值后，发送端打时间戳并估计当前的队列占用。

发送端保持对其队列占用的估计。对于发送的字节数，增加估计值；对于每经过8tick的预测，减少估计值。

Sprout预测未来5个tick将从队列排空的字节数。将其减去当前队列占用，就是可以安全发送的字节数。不断变化的窗口大小决定了可以传输的字节数。

## 问题

- 泊松过程建模的链路速率分布为0-12Mbps，因此无法追踪更高带宽的网络，除非增大速率的离散值个数。
- 需要设置延迟阈值和对应的置信区间
- 网络队列模型中的标准差和逃离速率是提前设定好的。实际应该也是变化的
- Sprout需要修改发送端和接收端和包结构，不适合移植或者在此基础上修改。Sprout只使用基于轨迹的评估，没有真实网络的测试。

