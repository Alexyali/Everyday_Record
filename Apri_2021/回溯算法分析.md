# 回溯算法分析

### `leetcode` 131 分割回文串

将给定字符串`s`分割为一系列字串，使每个子串都是回文串，返回`s`的所有分割方案。

思路：

- 确定`s`的每个子串是否为回文串：动态规划
- 设置指针从字符串首部搜索到尾部，如果从0到指针位置的子串为回文串，则将该字串加入到答案序列中，递归并从字串下一个位置开始重新搜索：回溯法，深度搜索每种可能

### 注意

写程序的时候，只需要知道函数的作用，不按照递归方法来思考。

```c++
// 字符串[0...k-1]已经分割好，从位置k开始分割
void dfs(string s, int k) {
    int n = s.size();
    // 如果k==n，表示这次分割完了全部字符串，可以将本次分割结果ret加入到res
    if (k==n) {
        res.push_back(ret);
        return;
    }
    // 从开始位置k开始遍历，到字符串末尾结束
    for (int i=k; i<n; i++) {
        // 判断子串s[k...i]是否为回文串
        // 如果是，说明可以分割，并进入递归
        // dp[i][j]表示字符串s[i..j]是否为回文串
        if(dp[k][i]) {
            // 将回文子串s[k...i]加入分割队列ret
            ret.push_back(s.substr(k,i-k+1));
            // 处理后续子串s[i+1...n]
            dfs(s, i+1);
            // 上述递归完成后，从ret中弹出子串s[k...i]，进入下一次循环
            ret.pop_back();
        }
    }
}
```

上述程序从for循环开始的代码可以按照广度搜索的思路来理解，只需要确定`dfs`的功能即可（划分后续子串）。而实际深度搜索在if判断`k==n`的时候结束，这时已经完成一条支路的回溯，将本次结果存入输出结果即可。