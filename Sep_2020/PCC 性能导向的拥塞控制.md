# PCC 性能导向的拥塞控制

## 摘要

- TCP的性能很差，因为它设计了固定的包级别事件来控制反馈，无法在变化的网络状况下取得一致的性能。性能导向的拥塞控制PCC算法可以持续观察动作和相应的实验性能的关系，并持续选择可以导致高性能的动作。实验证明PCC可以收敛到一个稳定且公平的平衡。

## 介绍

- PCC的目标是基于实时实验证据理解什么速率控制动作可以提升性能。PCC在一个短的时间周期内以速率r发送，并且观察结果（SACKs暗示每个包的交付、丢包和延迟） 。它把这些包级别事件放到一个效用函数里，用于描述一个目标，比如高吞吐和低丢包率。

- PCC会运行多个微实验，它会尝试发送两个不同的速率，并且移动到有更高效用函数的决策。PCC由追踪经验最优的发送速率的在线学习算法驱动，持续运行这些微实验。因此，PCC采用那些可以经验性达到持续性高性能的动作，而不是为潜在复杂网络做假设。

## PCC 架构

- 如果流在以某速率发送数据流的时候出现了丢包，发送端应该如何反应？因为实际网络情况很复杂，因此结果有很多种。TCP会将丢包视为拥塞，并减半其发送速率，但是在某些情况下则会降低性能。大量的TCP变种算法采用更加复杂的包级别事件和控制动作。但是这些方法仍然是固定联系了预先决定的事件和预先决定的控制响应，因此融入了关于网络的不可靠假设。如果这个不可靠假设和复杂的网络情况冲突，那么性能下降很明显。
- 备注：可以借鉴传统TCP拥塞控制在未拥塞情况下的速率调整方法。如果有一种判断丢包类型的算法，那么就可以在发生随机丢包时，还是按照原有方法增大速率。如果发生拥塞丢包，则减半发送速率。
- 备注：传统的TCP拥塞控制是将包级别事件通过固定规则映射到控制动作，因此很难在复杂的真实网络状况下达到持续的高性能。
- PCC的核心设计是基于成对的动作和直接观察到的性能结果做出控制决策。PCC的控制动作是选择发送速率。PCC将时间划分为连续的时间周期，称为MI，长度为1-2个RTT。在每个MI，PCC会测试一个动作：它会在整个时间周期以速率r发送数据。在一个RTT后，发送端会收到SACK。PCC会聚集这些SACK到有意义的性能指标，包括吞吐量、丢包率和延迟。通过效用函数将其合并为一个效用数值。最后的结果是PCC知道发送速率r时，得到效用u
- 通过微实验，PCC将特定动作和观察到的效用值联系起来。PCC持续运行微实验，并比较不同发送速率的效用。当发送速率为r时，它测试大小两个速率并移动到更高效用的方向。只有效用保持增加，它继续该方向。如果效用减少，它返回到决策阶段并测试高低两个速率。

## 原型设计

- 问题：每次实验都会影响网络状态，比如飞行数据总量，如何保证上次次实验的最优速率在接下来的MI也能取得最优？如何计算MI的间隔，是否提前知道网络的RTT？MI长度为2个RTT，那么这次MI发送速率r的结果需要等到第二个MI的中间才能算出效用值。那么决策是否存在延迟？
- 启动阶段：PCC启动速率为2MSS/RTT（也就是一个RTT发两个以太网包）并且每个MI倍增速率。PCC不会因为丢包退出启动阶段。相反，它会监测每次动作后的效用结果。一旦效用函数下降，PCC会退出启动阶段，返回到上一个效用函数高的速率。
- 决策阶段：假设PCC的速率为r，则PCC执行RCTs，PCC采用4个连续的MI并划分为两组，每组PCC尝试高低两种速率。执行完这四个连续实验后，PCC切换到速率r知道监视器获得这四次实验的效用值

