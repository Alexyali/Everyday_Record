# Copa: Practical Delay-Based Congestion Control for the Internet

`15th USENIX Symposium on Networked Systems Design and Implementation`  

## Abstract

本文提出了一种端到端拥塞控制算法，Copa. 包含三个创新点。首先，目标速率等于1/dq，dq是测量的队列延迟，在马尔可夫包到达模型下优化一个吞吐量和延迟的函数。其次，它朝目标速率的方向调整拥塞窗口，快速收敛到准确公平的速率。这两个方法让一族Copa流维持高带宽利用和低队列延迟。

实验证明Copa和Cubic取得了相似的吞吐量，但是延迟更低。相比BBR和PCC取得更低延迟，并且更公平，Copa可以和Cubic很好共存。Copa对非拥塞丢包鲁棒。

## Approach

Copa的目标是优化目标函数，包含平均吞吐量和数据包延迟。每个发送器的目标是优化U。延迟的惩罚因子决定了延迟的比重。

在特定简化的数据包到达模型假设下，稳定阶段的最佳发送速率是惩罚因子乘以队列延迟的倒数。将其作为每个发送端的目标速率。发送端使用RTT观察估计队列延迟，并迅速收敛到目标速率。该机制同时保证队列规律性清空，帮助所有节点获取队列延迟的准确估计。最后为了和缓冲填充流竞争，Copa使用一个AIMD窗口更新规则当它观察到瓶颈节点几乎清空时。

ps. 如果目标函数只包括吞吐量和延迟，用强化学习训练的模型是否就是基于延迟的，无法和基于丢包算法竞争？本文使用模型假设来计算最优的发送速率，以最优化目标函数。但是是否可以用强化学习来选择合适的速率？但是如果目标函数包含丢包率，则需要一段时间收集丢包率数据，导致增多的等待时间或者错误的丢包率。

## Algorithm

Copa有三个想法：

- 目标速率与测量的排队延迟成反比
- 根据窗口的更新规则将发送端移向目标速率
- TCP竞争模式很好地和缓冲填满流竞争

### 目标速率和更新规则

Copa使用cwnd，代表飞行数据包总数的上限。每次收到ACK就根据cwnd和RTTstanding计算速率。RTTstanding是一段时间窗内最小的RTT。dq=RTTstanding-RTTmin. RTTmin是更长一段时间的最小RTT。

如果当前速率超过目标速率，发送端则降低cwnd。否则，增加cwnd。

Copa发送端每次收到ACK就按照以下步骤运行：

- 更新队列延迟dq和srtt
- 设置目标速率
- 判断当前速率和目标的大小关系，对cwnd进行增加或减小`v/δ/dq`
- 速率参数v可以加速收敛

当一个流开始传输时，Copa会运行慢启动直到当前速率超过目标速率。

### 和缓冲填充流竞争机制

提出改进的Copa和Cubic竞争。默认模式的参数δ为0.5，在竞争模式下，δ动态调整以匹配TCP机制。Copa在不同的模式间切换取决于是否检测到长运行的缓冲填充流。

Copa的一个关键特征是当只有相似RTT的Copa流共享瓶颈节点时，每隔5RTT队列会清空。因此如果在上5个RTT内，发送端观察到队列几乎排空则保持默认模式，否则切换到竞争模式。

即使存在竞争的缓冲填充流，队列也可能近似为空（最近的一次丢包）。如果发生这种情况，Copa会切换到默认的模式。最终缓冲会再次被填满，因此Copa会再次切换到竞争模式。

- 注：这种切换方法增加了不必要的次数，影响吞吐量。会存在一些错误的切换到竞争模式